# Global Development Rules

This document defines global development rules and standards for all projects.

## Rule 1: Troubleshooting Documentation Organization

### Active vs Archived Troubleshooting

**Troubleshooting folder structure:**

```
troubleshooting/
├── active/              # Current/ongoing issues only
│   ├── documented-changes/    # Active troubleshooting documentation
│   └── scripted-fixes/       # Active troubleshooting scripts
└── archived/            # Resolved/completed issues
    ├── documented-changes/    # Past troubleshooting documentation
    └── scripted-fixes/        # Past troubleshooting scripts
```

### Criteria for Active vs Archived

**Active (keep in `active/`):**

- Issues that may recur
- Current workarounds in use
- Environment-specific configurations
- Ongoing monitoring procedures

**Archived (move to `archived/`):**

- Issues that have been permanently resolved
- One-time fixes that are no longer applicable
- Historical troubleshooting steps
- Past-tense documentation ("Fixed", "Resolved", "Was fixed")

### Naming Convention

- **Active files**: Use present tense or imperative ("FIX*", "RESOLVE*", "TROUBLESHOOT\_")
- **Archived files**: Prefix with date or move to dated subdirectories (e.g., `2024-12/`)

### Maintenance

- Review troubleshooting folder monthly
- Move resolved issues to archived within 30 days of resolution
- Keep only essential active troubleshooting in root troubleshooting folder
- Archive old troubleshooting after 90 days unless still actively referenced

## Rule 2: Global Neatness and Conciseness Standard

### Output Quality Standards

All documentation, code comments, and outputs must adhere to:

1. **Strong**: Assertive, confident language without hedging
2. **Neat**: Well-formatted, consistent structure, proper spacing
3. **Concise**: Direct, to-the-point, no unnecessary verbosity

### Documentation Standards

**Structure:**

- Clear hierarchical headings
- Consistent formatting throughout
- Bullet points for lists
- Code blocks with syntax highlighting
- Tables for structured data

**Language:**

- Use active voice
- Avoid filler words ("basically", "essentially", "kind of")
- Prefer specific terms over vague ones
- One idea per paragraph
- Maximum 3-4 sentences per paragraph

**Formatting:**

- 80-100 character line width for readability
- Consistent indentation (2 or 4 spaces)
- Clear section separators
- Proper markdown syntax

### Code Standards

**Comments:**

- Explain "why", not "what"
- Maximum 2-3 lines per comment block
- Use clear, concise language
- Remove commented-out code

**Naming:**

- Descriptive but concise
- Follow project conventions
- Avoid abbreviations unless standard

### Communication Standards

**Issue Reports:**

- Problem statement (1 sentence)
- Steps to reproduce (numbered list)
- Expected vs actual behavior
- Environment details (concise)

**Solution Documentation:**

- Solution (1-2 sentences)
- Implementation steps (numbered)
- Verification steps (concise checklist)

### Enforcement

- Code reviews must check for neatness and conciseness
- Documentation reviews before merging
- Automated formatting tools (Prettier, ESLint)
- Regular cleanup of verbose or unclear content

## Rule 3: Project Structure Standards

### Root Directory Cleanliness

**Keep in root:**

- Core documentation (README, ARCHITECTURE, etc.)
- Configuration files (.env.example, docker-compose.yml)
- Essential project files (package.json, etc.)

**Organize in subdirectories:**

- Documentation → `docs/`
- Scripts → `scripts/` or co-located with related docs
- Troubleshooting → `docs/troubleshooting/` with active/archived structure

### File Organization

- Group related files together
- Use consistent naming conventions
- Avoid deep nesting (max 3-4 levels)
- Keep related documentation and scripts together

## Rule 4: Version Control Standards

### Commit Messages

- Present tense, imperative mood ("Fix bug" not "Fixed bug")
- First line: 50 characters max
- Body: 72 characters per line
- Reference issue numbers when applicable

### Branch Naming

- `feature/` - New features
- `fix/` - Bug fixes
- `docs/` - Documentation changes
- `refactor/` - Code refactoring

## Rule 5: Documentation Lifecycle

### Active Documentation

- Keep current and accurate
- Update when code changes
- Remove outdated information immediately

### Historical Documentation

- Archive, don't delete
- Maintain in `archived/` or versioned directories
- Include context for historical reference

## Rule 6: Anti-Hallucination Protocol

### Core Principle

**Never claim, suggest, or implement anything without verification.**

### Verification Requirements

**Before making any claim:**

1. Verify code exists in the codebase
2. Check documentation matches reality
3. Test assumptions with actual code
4. Confirm file paths and structures
5. Validate API endpoints and responses

**Before suggesting solutions:**

1. Read actual code files, not assumptions
2. Check current implementation state
3. Verify dependencies and versions
4. Test solution in context
5. Confirm compatibility with existing code

### Code Verification

**Required checks:**

- Read files before modifying
- Verify function signatures exist
- Check imports and dependencies
- Confirm file paths are correct
- Validate syntax and structure

**Prohibited:**

- Assuming code structure without reading
- Suggesting non-existent functions
- Claiming features exist without verification
- Modifying files without reading first
- Making up API endpoints or responses

### Documentation Verification

**Before documenting:**

1. Verify feature actually exists in code
2. Test documented procedures
3. Confirm configuration values
4. Validate examples work
5. Check version compatibility

**Prohibited:**

- Documenting unimplemented features
- Describing non-existent functionality
- Claiming capabilities without proof
- Using placeholder examples without testing

### Uncertainty Handling

**When uncertain:**

1. State uncertainty explicitly
2. Use conditional language ("may", "might", "appears")
3. Request verification from user
4. Suggest investigation steps
5. Provide multiple possibilities if unclear

**Prohibited:**

- Making confident claims when uncertain
- Guessing implementation details
- Assuming without verification
- Presenting speculation as fact

### Source Citation

**Required for:**

- External API documentation
- Library or framework features
- Configuration examples
- Best practices from sources
- Version-specific information

**Format:**

- Link to official documentation
- Reference specific versions
- Cite code locations (file:line)
- Note when information is inferred

### Testing Requirements

**Before claiming something works:**

1. Verify in actual codebase
2. Test in relevant environment
3. Check error handling
4. Validate edge cases
5. Confirm integration points

**Prohibited:**

- Claiming code works without testing
- Suggesting untested solutions
- Assuming compatibility
- Skipping verification steps

### Fact-Checking Procedures

**For AI assistants:**

1. Read code files before suggesting changes
2. Search codebase for actual implementations
3. Verify dependencies in package.json
4. Check configuration files
5. Test commands in appropriate context

**For developers:**

1. Verify AI suggestions before implementing
2. Test code changes in development
3. Review generated code carefully
4. Check for logical errors
5. Validate against requirements

### Red Flags (Stop and Verify)

**Immediately verify if:**

- Feature mentioned doesn't appear in codebase
- File path seems incorrect
- Function signature doesn't match
- Configuration value seems wrong
- Error message doesn't match reality
- Version number seems inconsistent

### Verification Checklist

Before accepting any AI-generated solution:

- [ ] Code files actually exist at specified paths
- [ ] Functions/classes mentioned are in codebase
- [ ] Dependencies are in package.json
- [ ] Configuration matches actual files
- [ ] Examples have been tested
- [ ] API endpoints are correct
- [ ] Error messages match reality
- [ ] Version numbers are accurate
- [ ] File structures match description
- [ ] Implementation details are verified

### Error Handling

**When hallucination is detected:**

1. Acknowledge error immediately
2. Correct misinformation
3. Provide verified information
4. Explain verification process
5. Update documentation if needed

### Enforcement

**AI Model Requirements:**

- Must read files before modifying
- Must verify claims with codebase
- Must state uncertainty when unclear
- Must cite sources for external information
- Must test solutions before claiming they work

**Developer Requirements:**

- Verify AI suggestions before implementing
- Test all generated code
- Review changes carefully
- Report hallucinations for correction
- Maintain skepticism of unverified claims

## Implementation

These rules apply to:

- All new projects
- Existing projects during refactoring
- Code reviews and pull requests
- Documentation updates

## Review and Updates

- Review rules quarterly
- Update based on team feedback
- Document exceptions and rationale
- Ensure all team members are aware of changes
